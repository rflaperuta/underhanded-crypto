The exploit
-----------

This library has the very specific target of undermining the security of the
"internet of things". It was designed to be attractive to being integrated into
IoT hardware platforms where it will be difficult to patch once it is
discovered.  The backdoor also has a fairly strong degree of 
deniability. It arises from a rare, yet plausible bug. It would be very hard to
establish malice as opposed to simple oversight on the programmers part once the
exploit is publicly discovered.

The library implements the AES block cipher in CTR mode and for the most part
behaves as it is described in almost all circumstances it would normally be used
in. Notably it passes all the FIPS and RFC test vectors for AES encoding and can
interoperate with openssl. The library can be used in most any application where
AES is needed and will behave appropriately.

The library becomes exploitable specifically when it gets used as part of an
implementation of IPSec over IPv6 in a resource constrained IP stack. In such a
case, under normal operation the library will perform properly, interoperating
with other IPSec aes-ctr hosts. But when it is triggered by a forged ICMPv6
packet it will lead to a full plaintext reveal. Another forged ICMP packet will
restore the conforming behavior so that normal packet retries will mask the
improper behavior.

The bug is triggered when an encoded stream is split on a boundry that is not
divisible by 16 and then subsequently restarted. When this is done, the key
schedule will be reseeded by the current IV. In practice, this will not come up
due to buffers almost always being a power of two greater than 16 when data is
split up or when an odd size is needed, it is due to the end of an encryption
stream and not one that will be restarted. In order to take advantage of this,
we rely on a few things.

    - IPv6 implemntations must implement fragmentation to assemble packets of at
    least 1500 bytes over a link that only guanentees 1280 bytes.

    - On constrained systems, the tiny IP stack will generally
    assemble a single packet at a time, this is due to hardware and memory
    constraints. Meaning when fragmentation occurs, the encryption must pause
    and be resumed after the fragment boundry.

    - higher level protocols avoid fragmentation whenever possible, so
    fragmentation almost never occurs naturally unless forced with an unusually
    small MTU.

    - ICMP traffic is generally not validated, but packet to big ICMP traffic
    must be obeyed.

So in order to exploit a system integrating this library into their IPSec
implementation, the eavesdropper waits until encrypted communication is taking
place, sends some packet to big messages to force fragmentation at an odd
boundry reading the plaintext (since the key is the iv and the iv is in the
message) then sends another packet to big ICMP message to force it back onto a
16 byte boundry. The compromised packets will be dropped by the recieving host
as corrupted in flight due to the MAC not agreeing and the packets will be
resent with the new 16 byte aligned fragments properly encoded. By flutting back
and forth between MTUs, an eavesdropper can obtain almost the entire plaintext
of an encrypted transaction.

the bug
-------

The bug is due to the common case of a user declaring their own boolean type
rather than using the language built in one. Since C has had no boolean type
until recently, this is still a commonly seen C idiom. The issue is that by
declaring boolean as 'typedef char boolean', we only allocate 8 bits to a
boolean, however, some of the flags we are testing against mode are past the 8
bit boundry. In particular 'MODE_KEEPKEY' has the value 0x0400, so while
MODE_KEEPKEY&mode will have the correct value when used in a conditional, when
converted to our 'boolean' as it is implicitly done in the call to aes_setup,
the higher order bits are lost and the boolean is always assigned the false
value. The correct code would either use the <stdbool.h> header or the
!!(MODE_KEEPKEY&mode) construct to flatten in.


This is a very common and hard to track down bug and the typedef appears in many
libraries without a warning. A particularly egregious offender is the Arduino
libraries which contain 'typedef uint8_t boolean;' since C++ already has a
proper boolean 'bool'. 

Moral, always use the real stdbool bool, and never arduinos 'boolean', gtks
gboolean, or other disney-dollar APIs.

demonstration
-------------

the exploit/exploit program demonstrates this flaw, it will appear to encrypt
and decrypt properly, but if the wrong decryption key is given, the plaintext
will still be recovered after the first 500 bytes.


